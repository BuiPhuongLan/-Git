/**
 *	@author Nguyen Hua Phung
 *	@version 1.0
 *	23/10/2015
 * 	This file provides a simple version of code generator
 *  Student ID: 1510625
 */

package mc.codegen





//import mc.checker._
import mc.utils._
import java.io.{PrintWriter, File}


object CodeGenerator extends Utils {
  val libName = "io"
  def init() = List(
    Symbol("getInt",MType(List(),IntType),CName(libName)),
    Symbol("putInt",MType(List(IntType),VoidType),CName(libName)),
    Symbol("putIntLn",MType(List(IntType),VoidType),CName(libName)),
    Symbol("getFloat",MType(List(),FloatType),CName(libName)),
    Symbol("putFloat",MType(List(FloatType),VoidType),CName(libName)),
    Symbol("putFloatLn",MType(List(FloatType),VoidType),CName(libName)),
    Symbol("putBool",MType(List(BoolType),VoidType),CName(libName)),
    Symbol("putBoolLn",MType(List(BoolType),VoidType),CName(libName)),
    Symbol("putString",MType(List(StringType),VoidType),CName(libName)),
    Symbol("putStringLn",MType(List(StringType),VoidType),CName(libName)),
    Symbol("putLn",MType(List(),VoidType),CName(libName))
  )

	def gen(ast:AST,dir:File) = {

    val gl = init()     
		val gc = new CodeGenVisitor(ast,gl,dir)    
		gc.visit(ast, null);   
	}
}




case class ClassType(cname:String) extends Type



//case class SubContext(emit:Emitter,decl:List[Decl]) 

case class SubBody(frame:Frame,sym:List[Symbol]) 

class Access(val frame:Frame,val sym:List[Symbol],val isLeft:Boolean,val isFirst:Boolean)

trait Val
  case class Index(value:Int) extends Val
  case class CName(value:String) extends Val

case class Symbol(name:String,typ:Type,value:Val)
case class MType(partype:List[Type],rettype:Type) extends Type






class CodeGenVisitor(astTree:AST,env:List[Symbol],dir:File) extends BaseVisitor with Utils {
	
  val className = "MCClass"
  val path = dir.getPath()
  val emit = new Emitter(path+"/"+className+".j")


   override def visitProgram(ast:Program,c:Any) = {
      emit.printout(emit.emitPROLOG(className,"java.lang.Object"))    
      val lstVarDecl = ast.decl.filter(_.isInstanceOf[VarDecl]).asInstanceOf[List[VarDecl]]
      val glenv = lstVarDecl.foldLeft(env)((a,b) => {
          emit.printout(emit.emitATTRIBUTE(b.variable.name,b.varType,false,null))
          Symbol(b.variable.name,b.varType,null) :: a
        }
      )

      // generate default constructor 
      genMETHOD(FuncDecl(Id("<init>"),List(),null,Block(List(),List())),c,new Frame("<init>",VoidType))
      genMETHOD(FuncDecl(Id("<clinit>"),List(),null,Block(List(),List())),lstVarDecl,new Frame("<clinit>",VoidType))
      val lstFuncDecl = ast.decl.filter(_.isInstanceOf[FuncDecl]).asInstanceOf[List[FuncDecl]]
      val lstSym = lstFuncDecl.foldLeft(glenv)((a,b) => 
        Symbol(b.name.name,MType(b.param.map(_.varType),b.returnType),CName(className)) :: a) 

      lstFuncDecl.map(x => x.accept(this,SubBody(null,lstSym)))  
      emit.emitEPILOG()
      c   
  }
  
 

    /** generate code for default constructor 

   *  @param consdecl the function declaration whose code will be generated by this method
   *  @param frame the frame where the initialization happen 
   *  @param o the referencing environment
   */

  def visitStmt(stmt:Stmt,frame:Frame,en:List[Symbol]) = {
    if (stmt.isInstanceOf[Expr]) {
      if (stmt.isInstanceOf[BinaryOp] && stmt.asInstanceOf[BinaryOp].op == "=")
        emit.printout(stmt.accept(this,new Access(frame,en,false,false)).asInstanceOf[(String,Type)]._1)
      else
        emit.printout(stmt.accept(this,new Access(frame,en,false,true)).asInstanceOf[(String,Type)]._1)
    }
    else if (stmt == Break) 
      emit.printout(emit.emitGOTO(frame.getBreakLabel(),frame))
    else if (stmt == Continue) 
      emit.printout(emit.emitGOTO(frame.getContinueLabel(),frame))
    else stmt.accept(this,SubBody(frame,en))
  }

  def genMETHOD(consdecl:FuncDecl,o:Any,frame:Frame) = {
    
    //val isInit = consdecl.returnType == null
    val isMain = consdecl.name.name == "main" && consdecl.param.length == 0 && consdecl.returnType == VoidType
    val methodName = consdecl.name.name
    val returnType = if (methodName == "<init>" || methodName == "<clinit>") VoidType else consdecl.returnType
    val intype = if (isMain) List(ArrayPointerType(StringType)) else consdecl.param.map(_.varType)
    val mtype =  MType(intype,returnType)
    if (methodName == "<init>") emit.printout(emit.emitMETHOD(methodName, mtype, false, frame))
    else emit.printout(emit.emitMETHOD(methodName, mtype, true, frame))

    frame.enterScope(true);

    // Generate code for parameter declarations
    if (methodName == "<init>") emit.printout(emit.emitVAR(frame.getNewIndex,"this",ClassType(className),frame.getStartLabel,frame.getEndLabel,frame))
    if (isMain) emit.printout(emit.emitVAR(frame.getNewIndex,"args",ArrayPointerType(StringType),frame.getStartLabel,frame.getEndLabel,frame))

    val param = consdecl.param.foldLeft(List[Symbol]())((a,b) => b.accept(this,SubBody(frame,a)).asInstanceOf[List[Symbol]])

    val body = consdecl.body.asInstanceOf[Block]
    val local = body.decl.foldLeft(List[Symbol]())((a,b) => b.accept(this,SubBody(frame,a)).asInstanceOf[List[Symbol]])

    emit.printout(emit.emitLABEL(frame.getStartLabel(),frame))
    
    //Generate code for statements
    if (methodName == "<init>") {
      emit.printout(emit.emitREADVAR("this",ClassType(className),0,frame))
      emit.printout(emit.emitINVOKESPECIAL(frame))
      
    }
    else if (methodName == "<clinit>") {
      val lstVarDecl = o.asInstanceOf[List[VarDecl]]
      lstVarDecl.map(x=>
        x.varType match {
          case ArrayType(n,t) => {
            emit.printout(
              emit.emitPUSHICONST(n.value,frame) 
              + emit.emitNEWARRAY(t,frame)
              + emit.emitPUTSTATIC(className+"."+x.variable.name,x.varType,frame)
            )
          }
          case _ => {}
        }
      )
    }

    else {
      val env = param ++ local ++ o.asInstanceOf[List[Symbol]]
      body.stmt.map(visitStmt(_,frame,env))
    }
    emit.printout(emit.emitLABEL(frame.getEndLabel(),frame))
    if (returnType == VoidType) emit.printout(emit.emitRETURN(VoidType,frame));
    emit.printout(emit.emitENDMETHOD(frame));
    frame.exitScope();  
  }

  override def visitVarDecl(ast:VarDecl,o:Any) = {
    val subctxt = o.asInstanceOf[SubBody]
    val frame = subctxt.frame
    val lst = subctxt.sym
    val idx = frame.getNewIndex()
    emit.printout(emit.emitVAR(idx, ast.variable.name, ast.varType, frame.getStartLabel(), frame.getEndLabel(), frame))
    if (ast.varType.isInstanceOf[ArrayType]) {
      val arrType = ast.varType.asInstanceOf[ArrayType]
        emit.printout(
          emit.emitPUSHICONST(arrType.dimen.value,frame)
          + emit.emitNEWARRAY(arrType.eleType,frame)
          + emit.emitWRITEVAR(ast.variable.name,arrType,idx,frame)
        )
    }
    Symbol(ast.variable.name,ast.varType,Index(idx)) :: lst
    
  }

  override def visitFuncDecl(ast:FuncDecl,o:Any) = {
    val subctxt = o.asInstanceOf[SubBody]
    val frame = new Frame(ast.name.name,ast.returnType)
    genMETHOD(ast,subctxt.sym,frame)
    // val parType = ast.param.map(_.varType)
    // SubBody(frame,Symbol(ast.name.name,MType(parType,ast.returnType),CName(className))::subctxt.sym)
  }

  override def visitBlock(ast:Block,o:Any) = {
    val subctxt = o.asInstanceOf[SubBody]
    val frame = subctxt.frame
    frame.enterScope(false)
    val lstVarDecl = ast.decl.asInstanceOf[List[VarDecl]]
    val local = lstVarDecl.foldLeft(List[Symbol]())((a,b) =>
      b.accept(this,SubBody(frame,a)).asInstanceOf[List[Symbol]])

    emit.printout(emit.emitLABEL(frame.getStartLabel(),frame))
    // val lstArrDecl = local.filter(_.typ.isInstanceOf[ArrayType]).map(x=> {
    //     val arrType = x.typ.asInstanceOf[ArrayType]
    //     emit.printout(
    //       emit.emitPUSHICONST(arrType.dimen.value,frame)
    //       + emit.emitNEWARRAY(arrType.eleType,frame)
    //       + emit.emitWRITEVAR(x.name,arrType,x.value.asInstanceOf[Index].value,frame)
    //     )
    //   }
    // )
    val env = local ++ subctxt.sym
    ast.stmt.map(visitStmt(_,frame,env))

    emit.printout(emit.emitLABEL(frame.getEndLabel(),frame))
    frame.exitScope();
  }

  override def visitIf(ast:If,o:Any) = {
    val subctxt = o.asInstanceOf[SubBody]
    val frame = subctxt.frame
    val env = subctxt.sym
    val exp = ast.expr.accept(this,new Access(frame,env,false,true)).asInstanceOf[(String,Type)]
    emit.printout(exp._1)
    val label1 = frame.getNewLabel()
    emit.printout(emit.emitIFEQ(label1,frame))
    visitStmt(ast.thenStmt,frame,env)
    if (ast.elseStmt != None) {
      val label2 = frame.getNewLabel()
      emit.printout(emit.emitGOTO(label2,frame))
      emit.printout(emit.emitLABEL(label1,frame))
      visitStmt(ast.elseStmt.get,frame,env)
      emit.printout(emit.emitLABEL(label2,frame))
    }
    else emit.printout(emit.emitLABEL(label1,frame))
  }

  override def visitFor(ast:For,o:Any) = {
    val subctxt = o.asInstanceOf[SubBody]
    val frame = subctxt.frame
    val exp1 = ast.expr1.accept(this,new Access(frame,subctxt.sym,false,true)).asInstanceOf[(String,Type)]
    val exp2 = ast.expr2.accept(this,new Access(frame,subctxt.sym,false,true)).asInstanceOf[(String,Type)]
    val exp3 = ast.expr3.accept(this,new Access(frame,subctxt.sym,false,true)).asInstanceOf[(String,Type)]
    emit.printout(exp1._1 + emit.emitPOP(frame)) 
    frame.enterLoop()
    val label = frame.getNewLabel()
    val conLabel = frame.getContinueLabel()
    val brkLabel = frame.getBreakLabel()
    emit.printout(emit.emitLABEL(label,frame) + exp2._1 
      + emit.emitIFEQ(brkLabel,frame))
    visitStmt(ast.loop,frame,subctxt.sym)
    emit.printout(emit.emitLABEL(conLabel,frame) 
      + exp3._1 + emit.emitPOP(frame) + emit.emitGOTO(label,frame)
      + emit.emitLABEL(brkLabel,frame)) 
    frame.exitLoop()
  }

  override def visitDowhile(ast:Dowhile,o:Any) = {
    val subctxt = o.asInstanceOf[SubBody]
    val frame = subctxt.frame
    val exp = ast.exp.accept(this,new Access(frame,subctxt.sym,false,true)).asInstanceOf[(String,Type)]
    frame.enterLoop()
    val label = frame.getNewLabel()
    val conLabel = frame.getContinueLabel()
    val brkLabel = frame.getBreakLabel()
    emit.printout(emit.emitLABEL(label,frame))
    ast.sl.map(visitStmt(_,frame,subctxt.sym))
    emit.printout(emit.emitLABEL(conLabel,frame) + exp._1 + emit.emitIFNE(label,frame)
      + emit.emitLABEL(brkLabel,frame))
    frame.exitLoop()
  }

  override def visitReturn(ast:Return,o:Any) = {
    if (ast.expr != None) {
      val ctxt = o.asInstanceOf[SubBody]
      val frame = ctxt.frame
      val exp = ast.expr.get.accept(this,new Access(frame,ctxt.sym,false,true)).asInstanceOf[(String,Type)]
      if (frame.returnType == FloatType && exp._2 == IntType)
      emit.printout(exp._1 + emit.emitI2F(frame) + emit.emitRETURN(FloatType,frame))
      else emit.printout(exp._1 + emit.emitRETURN(exp._2,frame))
    }
  }


  override def visitBinaryOp(ast:BinaryOp,o:Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    val left = ast.left.accept(this,new Access(frame,ctxt.sym,false,true)).asInstanceOf[(String,Type)]
    val right = ast.right.accept(this,new Access(frame,ctxt.sym,false,true)).asInstanceOf[(String,Type)]

    ast.op match {
      case "+" | "-" | "*" | "/" => {
        if (left._2 == right._2) (
          left._1 + right._1 + emit.emitAROP(ast.op,left._2,frame),
          left._2
        )
        else if (left._2 == IntType && right._2 == FloatType) (
          left._1 + emit.emitI2F(frame) + right._1 + emit.emitAROP(ast.op,FloatType,frame),
          FloatType
        )
        else (
          left._1 + right._1 + emit.emitI2F(frame) + emit.emitAROP(ast.op,FloatType,frame),
          FloatType
        )
      }
      case "%" => (left._1 + right._1 + emit.emitMOD(frame), IntType)
      case "<" | "<=" | ">" | ">=" | "==" | "!="  => {
        if (left._2 == right._2) (left._1 + right._1 + emit.emitREOP(ast.op,frame), BoolType)
        else if (left._2 == IntType && right._2 == FloatType) 
          (left._1 + emit.emitI2F(frame) + right._1 + emit.emitFCMPL(ast.op,frame), BoolType)
        else (left._1 + right._1 + emit.emitI2F(frame) + emit.emitFCMPL(ast.op,frame), BoolType)
      }
      case "&&" =>  {
        val label1 = frame.getNewLabel()
        val label2 = frame.getNewLabel()
        (left._1 + emit.emitIFNE(label1,frame) + emit.emitPUSHICONST(0,frame) + emit.emitGOTO(label2,frame) 
          + emit.emitLABEL(label1,frame) + right._1 + emit.emitLABEL(label2,frame),
        BoolType)
      }
      case "||" => {
        val label1 = frame.getNewLabel()
        val label2 = frame.getNewLabel()
        (left._1 + emit.emitIFEQ(label1,frame) + emit.emitPUSHICONST(1,frame) + emit.emitGOTO(label2,frame) 
          + emit.emitLABEL(label1,frame) + right._1 + emit.emitLABEL(label2,frame),
        BoolType)
      }
      case "=" => {        
        val left2 = ast.left.accept(this,new Access(frame,ctxt.sym,true,false)).asInstanceOf[(String,Type)]
        val right1 = if (left2._2 == FloatType && right._2 == IntType) right._1 + emit.emitI2F(frame)
          else right._1
        if (ast.left.isInstanceOf[ArrayCell]) {
          val left1 = ast.left.accept(this,new Access(frame,ctxt.sym,true,true)).asInstanceOf[(String,Type)]
          if (ctxt.isFirst) (left1._1 + right1 + emit.emitDUPX2(frame) + left2._1, left2._2)
          else (left1._1 + right1 + left2._1, left2._2) 
        }
        else {
          if (ctxt.isFirst) (right1 + emit.emitDUP(frame) + left2._1, left2._2)
          else (right1 + left2._1, left2._2)
        }
      }
            
    }
  }

  override def visitUnaryOp(ast:UnaryOp,o:Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    val body = ast.body.accept(this,new Access(frame,ctxt.sym,false,true)).asInstanceOf[(String,Type)]
    ast.op match {
      case "-" => (body._1 + emit.emitNEGOP(body._2,frame), body._2)
      case "!" => (body._1 + emit.emitNOT(body._2,frame), body._2)
    }
  }

  override def visitCallExpr(ast:CallExpr,o:Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    val sym = lookup(ast.method.name,ctxt.sym,(x:Symbol)=>x.name).get
    val cname = sym.value.asInstanceOf[CName].value
    val typ = sym.typ.asInstanceOf[MType]
    val parType = typ.partype

    val in = ast.params.zip(parType).foldLeft(("",List[Type]()))((y,x)=>
      {
        val (str1,typ1) = visit(x._1,new Access(frame,ctxt.sym,false,true)).asInstanceOf[(String,Type)]
        if (x._2 == FloatType && typ1 == IntType) (y._1 + str1 + emit.emitI2F(frame), y._2 :+ x._2)
        else (y._1 + str1, y._2 :+ x._2)
      }
    )

    (in._1 + emit.emitINVOKESTATIC(cname+"/"+ast.method.name,typ,frame), typ.rettype)          
  }

  override def visitId(ast:Id,o:Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    val sym = lookup(ast.name,ctxt.sym,(x:Symbol)=>x.name).get
    val typ = sym.typ
    val idx = sym.value
    if (ctxt.isLeft) {
      if (idx != null) (emit.emitWRITEVAR(ast.name,typ,idx.asInstanceOf[Index].value,frame),typ)
      else (emit.emitPUTSTATIC(className+"."+ast.name,typ,frame),typ)
    }
    else {
      if (idx != null) (emit.emitREADVAR(ast.name,typ,idx.asInstanceOf[Index].value,frame),typ)
      else (emit.emitGETSTATIC(className+"."+ast.name,typ,frame),typ)     
    }
  }

  override def visitArrayCell(ast:ArrayCell,o:Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    val idx = ast.idx.accept(this, new Access(frame,ctxt.sym,false,true)).asInstanceOf[(String,Type)]
    val arr = ast.arr.accept(this, new Access(frame,ctxt.sym,false,true)).asInstanceOf[(String,Type)]   
    val typ = arr._2 match {
      case ArrayType(_,t) => t
      case ArrayPointerType(t) => t
    } 

    if (ctxt.isLeft) {
      if (ctxt.isFirst) (arr._1 + idx._1, typ)
      else (emit.emitASTORE(typ,frame), typ)      
    }
    else (arr._1 + idx._1 + emit.emitALOAD(typ,frame), typ)
  }


  override def visitIntLiteral(ast:IntLiteral,o:Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    (emit.emitPUSHICONST(ast.value, frame),IntType)
  }

  override def visitFloatLiteral(ast:FloatLiteral,o:Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    (emit.emitPUSHFCONST(ast.value.toString(), frame),FloatType)
  }

  override def visitStringLiteral(ast:StringLiteral,o:Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    (emit.emitPUSHCONST("\"" + ast.value + "\"", StringType, frame),StringType)
  }
  
  override def visitBooleanLiteral(ast:BooleanLiteral,o:Any) = {
    val ctxt = o.asInstanceOf[Access]
    val frame = ctxt.frame
    (emit.emitPUSHICONST(ast.value.toString(), frame),BoolType)
  }
}